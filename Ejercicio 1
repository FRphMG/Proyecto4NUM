########## a) BISECCION ##########

def Biseccion(Tol, N, f, a, b):
    # Verificamos si hay un cambio de signo en el intervalo [a, b]
    fa, fb = f(a), f(b)  # Evaluamos la función en los extremos del intervalo
    if fa * fb > 0.0:  # Si el producto es positivo, no hay raíz en el intervalo
        print("No tiene raíces en el intervalo")
        return None  # Devolvemos None si no hay raíz en el intervalo

    x0 = a  # Inicializamos x0 con el valor de 'a' para la primera iteración
    Iter = 0  # Inicializamos el contador de iteraciones en 0
    
    # Comienza el ciclo de bisección, se ejecutará hasta que se alcance la tolerancia o se agoten las iteraciones
    while Iter < N:
        x1 = (a + b) / 2.0  # Calculamos el punto medio del intervalo [a, b]
        fx1 = f(x1)  # Evaluamos la función en el punto medio x1
        
        # Verificamos si el valor de la función en x1 es suficientemente pequeño
        # o si el cambio entre x1 y x0 es suficientemente pequeño
        if abs(fx1) <= Tol or abs(x1 - x0) <= Tol:
            print(f"Tu raíz es aproximadamente {x1}")  # Si se cumple la condición de tolerancia, imprimimos el resultado
            return x1  # Devolvemos la raíz aproximada y terminamos la función
        
        # Actualizamos los extremos del intervalo en función del signo de f(x1)
        if fa * fx1 < 0:  # Si hay un cambio de signo entre fa y fx1, la raíz está en [a, x1]
            b = x1  # Actualizamos b a x1
            fb = fx1  # Evaluamos la función en el nuevo extremo b
        else:  # Si no, la raíz está en [x1, b]
            a = x1  # Actualizamos a a x1
            fa = fx1  # Evaluamos la función en el nuevo extremo a
        
        x0 = x1  # Actualizamos x0 para la siguiente iteración
        Iter += 1  # Aumentamos el contador de iteraciones
    
    # Si no encontramos la raíz dentro del número máximo de iteraciones, mostramos el valor aproximado
    print(f"El valor aproximado de tu raíz es {x1}")
    return x1  # Devolvemos el valor aproximado de la raíz después de N iteraciones

# Solicitar los parámetros al usuario
f_str = input("Función: ")  # Pedimos al usuario que ingrese la función en formato de texto
f = lambda x: eval(f_str)  # Convertimos el string de la función en una función real utilizando 'eval'

# Pedimos los valores de tolerancia, número de iteraciones, y el intervalo [a, b]
Tol = float(input("Tolerancia: "))  # Tolerancia para la precisión de la raíz
N = int(input("Número de iteraciones: "))  # Número máximo de iteraciones
a = float(input("Intervalo valor de a: "))  # Extremo izquierdo del intervalo
b = float(input("Intervalo valor de b: "))  # Extremo derecho del intervalo

# Llamamos a la función de bisección con los parámetros dados
Biseccion(Tol, N, f, a, b)  # Ejecutamos el método de bisección



########## b) SECANTE ##########

def Secante(f, Tol, N, x0, x1):
    # N es el número de iteraciones
    # Tol es la tolerancia
    # f es la función a la cual se le quiere obtener las raíces
    # x0 es el extremo izquierdo del intervalo
    # x1 es el extremo derecho del intervalo

    # contador de iteraciones
    n = 1
    
    # mientras no se haya superado el límite de iteraciones
    while( N >= n ):
        # cálculo de los valores de fx0 y fx1, es decir, evaluamos la función en los puntos x0 y x1
        fx0, fx1 = f(x0), f(x1)
        
        # se calcula la siguiente aproximación de la raíz usando la fórmula de la secante
        xn = x1 - fx1 * ((x1 - x0) / float(fx1 - fx0))
        
        # en caso de que se cumplan los criterios de paro
        # - la función en xn sea menor o igual a la tolerancia
        # - la diferencia entre x0 y x1 sea menor o igual a la tolerancia
        # se devuelve la raíz aproximada
        if (abs(f(xn)) <= Tol and abs(x0 - x1) <= Tol):
            return xn
        
        # si no se cumple el criterio de paro, actualizamos los valores de x0 y x1
        # x0 pasa a ser x1, y x1 pasa a ser xn (la nueva aproximación)
        x0 = x1
        x1 = xn
        
        # incremento en las iteraciones
        n += 1

    # Si no se alcanza el criterio de paro, imprimimos el valor aproximado de la raíz después del máximo de iteraciones
    else:
        print("El valor aproximado de tu raíz es " + str(x1))

# Solicitamos al usuario la función, tolerancia, número de iteraciones, y los puntos de inicio
f_str = input("Función: ")
f = lambda x: eval(f_str)  # Convertimos el string introducido por el usuario en una función
Tol = float(input("Tolerancia: "))
N = int(input("Número de iteraciones: "))
x0 = float(input("Intervalo valor de x0: "))
x1 = float(input("Intervalo valor de x1: "))

# Llamamos a la función Secante para encontrar la raíz
Secante(f, Tol, N, x0, x1)

